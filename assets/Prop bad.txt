
import GaFr.GFGame;
import GaFr.GFStamp;
import GaFr.GFFont;
import GaFr.Gfx;
import GaFr.GFU;
import GaFr.GFTexture;
import GaFr.GFKey;

import java.util.*;
import java.io.*;
import java.lang.Integer;
import java.lang.Math;

public class Prop { 

  int id;
  int icon;
  int x;
  int y;
  HashMap<String, String> metadata;
  boolean hasMetadata;
  boolean exists;

  static String[][] predeterminedProps = new String[50][3];

  
  static HashMap<String, Integer> tileDict;
  
  // A prop has 3 arguments: the icon, and the location in x and y coordinates.
  // Metadata, if any, is put in separately with the setMetadata argument.
    public static void initProp(){
      //predeterminedProps[0][0] ="WALL_GLYPH";
      //predeterminedProps[0][1] ="GLYPH_ENGRAVED";
      //predeterminedProps[0][2] ="{examine:What a strange symbol.}";
      
      System.out.println(tileDict.get("NOTHING".trim()));
      System.out.println(Integer.parseInt("2".trim()));
      System.out.println(Integer.parseInt("2".trim()));
      Prop prop = new Prop(
        tileDict.get("NOTHING".trim()),
        Integer.parseInt("2".trim()),
        Integer.parseInt("2".trim())
        );
    }

    public static void getTileDict(String key, int value) {
      tileDict.put(key, value);

    }


    public Prop(int inicon, int inx, int iny) {
        id = -1;
        icon = inicon;
        x = inx;
        y = iny;
        metadata = new HashMap<String, String>();
        hasMetadata = false;
        exists = true;
    }

    public int getX() {
      return this.x;
    }

    public int getY() {
      return this.y;
    }

    public int getIcon() {
      return this.icon;
    }

    public String getString() {
      return "x: "+this.x+" y: "+this.y+" icon: "+this.icon+" id: "+this.id;
    }

    public void setMetadata(String metadata_raw) {
      // example metadata: {teleport:1,2; lock:blue_key}
      metadata_raw = metadata_raw.substring(1, metadata_raw.length() - 1); // cut off the {} and remove any whitespace
      if (metadata_raw.equals("")) {
        this.metadata.put("none", "none");
        this.hasMetadata = false;
      } else {
        String[] metadataArray = metadata_raw.split(";"); // example data now: ["teleport:1,2", "lock:blue_key"]
        String[] pairArray;
        for (int i = 0; i < metadataArray.length; i++) {
          pairArray = metadataArray[i].split(":");
          this.metadata.put(pairArray[0].trim(), pairArray[1].trim());
          //System.out.println("New piece of metadata added: "+pairArray[0].trim()+":"+pairArray[1].trim());
          // example data now: "teleport":"1,2", "lock":"blue_key"
          this.hasMetadata = true;
        }
      }


    }

    public void addMetadataKey(String key, String value) {
      this.metadata.put(key, value);
    }

    // Called every time the player directly touches the object.
    public boolean tryOverlapAction() {
      if ( Game.editMode || !(this.exists)) {
        // actions are disabled in edit mode
        // nonexistent items are no longer interacted with
        return false;
      }

      if (this.metadata.containsKey("teleport")) {
        int teleportDestX = Integer.parseInt(metadata.get("teleport").trim().split(",")[0]);
        int teleportDestY = Integer.parseInt(metadata.get("teleport").trim().split(",")[1]);
        Game.setCharX(teleportDestX);
        Game.setCharY(teleportDestY);
        Fog.clearFog();
        return true;
      } 
      else if (this.metadata.containsKey("destination")) {
        return this.doDestination();
      }else if (this.metadata.containsKey("pickup_item")) {
        if (Inventory.addToInventory(metadata.get("pickup_item").trim()) == true) {
          // successful add, hide this item
          this.exists = false;
        } 

      }

      return false;
    }

    public boolean tryTouchAction() {
      if (this.metadata.containsKey("locked") ) {
        doUnlock();
      }
      if (this.metadata.containsKey("examine") ) {
        doExamine();
      }
      if (this.metadata.containsKey("inventory") ) {
        System.out.println(this.metadata.get("inventory"));
      }
      return false;
    }

    public boolean doUnlock() {
        if ( !Inventory.inventoryTake(metadata.get("locked")) ) {
          // you don't have it, so no door for you
          System.out.println("You don't have the key.");
          return false;
        }
        System.out.println("You unlocked it.");
        this.metadata.remove("locked");
        this.metadata.put("unlocked", "its_open");
        this.icon = this.icon - 1; // The standard for switching to the "unlocked" version.
        return true;

    }

    public boolean doExamine() {
      if (this.metadata.containsKey("examine")) {
        Game.dialogueBox.addMultipleLines(this.metadata.get("examine"));
        return true;
      } else {
        System.out.println("No examine");
        return false;
      }

    }


    // Go to the destination pointed to by this prop
    public boolean doDestination() {
        if (this.metadata.containsKey("locked")) {
          doUnlock();

        }
        if (!this.metadata.containsKey("locked")) {
          String[] destinationMetadata = metadata.get("destination").trim().split(",");
          try {
            if (destinationMetadata.length == 1) {
              Game.loadLevel("assets/maps/"+destinationMetadata[0]);
              return true;
            } else if (destinationMetadata.length == 3) {
              Game.loadLevel("assets/maps/"+destinationMetadata[0], Integer.parseInt(destinationMetadata[1]), Integer.parseInt(destinationMetadata[2]));
              return true;
            }
          }
          catch (Exception e) {
            System.out.println("Failure to load new map.");
            Game.errorScreen();
          }
          return false;
        }
        return false;
        
    }


  // Given a text file string formatted properly (see props_example.txt), will parse it into the Props list.
  // Props are any tile which can be interacted with.
  static Prop[] readProps(String propsString) {
    String[] propsArray = propsString.split("\n");
    String[] lineParser;
    Prop[] newProps = new Prop[propsArray.length];
    boolean isInt = false;


    for (int i = 0; i < propsArray.length; i++) {
      lineParser = propsArray[i].split(",", 4);
      System.out.println( propsArray[i]);

      // if there are enough arguments, create a new prop
        try {
          isInt = ( Integer.parseInt(lineParser[0].trim()) > 0 );
        } catch (Exception e) {
          isInt = false;
        }

          if (isInt) {
            newProps[i] = parsePropNumber(lineParser);
          } else if (tileDict.containsKey(lineParser[0].trim())) {
            newProps[i] = parsePropName(lineParser);
          } else  {
            newProps[i] = parsePropPredefined(lineParser);
          // } else {
          //   System.out.println("Failure loading prop #"+i);
          //   break;
        
          }

        // stores the prop's ID in the props map
        Game.propsMap[newProps[i].getX()][newProps[i].getY()] = i;
    }
  return newProps;
  }

  static Prop parsePropNumber(String[] lineParser) {
    
    Prop prop;
          prop = new Prop(
            Integer.parseInt(lineParser[0].trim()),
            Integer.parseInt(lineParser[1].trim()),
            Integer.parseInt(lineParser[2].trim())
            );
          prop.setMetadata(lineParser[3].trim());
          System.out.println("Failure -- prop parse type 1");
          prop = new Prop(1,-1,-1);
      
    return prop;
  }

  static Prop parsePropName(String[] lineParser) {
    Prop prop;
        
    System.out.println(Game.tileDict.get(lineParser[0].trim()));
    System.out.println(Integer.parseInt(lineParser[1].trim()));
    System.out.println(Integer.parseInt(lineParser[2].trim()));
    prop = new Prop(
      tileDict.get(lineParser[0].trim()),
      Integer.parseInt(lineParser[1].trim()),
      Integer.parseInt(lineParser[2].trim())
      );
    prop.setMetadata(lineParser[3].trim());
    return prop;
  }

  static Prop parsePropPredefined(String[] lineParser) {
    Prop prop;
          String[] predefined = new String[3];
          String[] prePropsStr = new String[2];
          int i = 0;
          while (predeterminedProps[i][0] != lineParser[0].trim()) {
            i++;
          }
          predefined = predeterminedProps[i];
          prop = new Prop(
            tileDict.get(predefined[1]),
            Integer.parseInt(lineParser[1].trim()),
            Integer.parseInt(lineParser[2].trim())
            );
            
          prePropsStr[0] = predefined[2].substring(1, predefined[2].length() - 1);
          prePropsStr[1] = lineParser[3].trim().substring(1, lineParser[3].trim().length() - 1);
          prop.setMetadata("{"+prePropsStr[0]+","+prePropsStr[1]+"}");

      
    return prop;
  }

  
}

